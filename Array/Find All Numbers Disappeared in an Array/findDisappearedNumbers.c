/**
 * Return an array of size *returnSize.
 * Note: The returned array must be malloced, assume caller calls free().
 */
 /**
 这题的思路如下：
 先遍历一遍数组，将每个位置的元素值对应的位置上的元素值取相反数，如果该位置原本就是相反数，就保持不变
 拿题目中的例子来说就是：
 一开始给出的数组是：4 3 2 7 8 2 3 1
 先取第一个元素为4，发现4号位置的元素值为7，非负数，于是将4号位置的7修改为-7，计数器+1
 再取第二个元素3，发现3号位置的元素值为2，非负，于是将3号位置的2改为-2，计数器+1
 取第三个元素为-2，取绝对值为2，由于2号位置的元素值为3，非负，于是将1号位置的元素值3改为-3，计数器+1
 取第四个元素-7，取绝对值为7，由于7号位置的元素值为3，非负，于是将7号位置的元素值由3改为-3，计数器+1
 取第五个元素8，发现8号位置的元素值为1，非负，于是将8号位置的元素值由1修改为-1，计数器+1
 取第六个元素2，发现2号位置的元素值为-3，已经取过相反数了，已经取过相反数了，不需要操作，计数器不变
 取第七个元素-3，取绝对值为3，由于3号位置的元素值为-2，已经取过相反数了，不需要操作，计数器不变
 取第八个元素-1，取绝对值为1，由于1号位置的元素值为4，非负，于是将1号元素由4变成-4，计数器+1
 遍历完整个数组后发现计数器为6，也就是说有两个元素没有出现过
 此时的数组为：-4 -3 -2 -7 8 2 -3 -1
 只有五号元素和六号元素为正，也就是说，在第一次的遍历中没有出现过5和6两个数字，将这两个数字放进新的数组内返回即可
 */
int* findDisappearedNumbers(int* nums, int numsSize, int* returnSize) {
    int i,cnt=0;int val;
    for(i=0;i<numsSize;i++)
    {
        val = nums[i]>0?nums[i]:(-nums[i]); //取当前位置元素值的绝对值
        if(nums[val-1]>0)//该位置乘为负数
        {
            nums[val-1] = -nums[val-1];
            cnt++;
        }
    }
    *returnSize = numsSize - cnt;int j =0;
    int *res = (int*)malloc((*returnSize)*sizeof(int));
    for(i=0;i<numsSize;i++)//遍历整个数组，寻找大于0的元素
    {
        if(nums[i]>0)
        {
            res[j] = i+1;
            j++;
        }
    }
    return res;
}
